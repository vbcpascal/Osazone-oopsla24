{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes       #-}
module Config.Lifting.RDReport where

-- import Config.Core.Builder (readLang)
-- import Config.Lifting.Builder
-- import Data.Bifunctor (Bifunctor (bimap))
-- import Data.Functor ((<&>))
-- import Data.List (partition, (\\))
-- import Data.Map (Map, fromList, keys, toList)
-- import Language.Core.AST
-- import Language.Dependency.Dependency
-- import Language.Dependency.Resolver
-- import Lifting.Sugar
-- import Text.RawString.QQ
-- import Text.StringTemplate
-- import Utils.Pretty
-- import Utils.System (createAndWriteFile)
-- import System.FilePath ((</>))

{- 
sgrdReport :: FilePath -> IO ()
sgrdReport path = do
  (_, exts) <- readLifting path
  (_, lang) <- readLang path
  let rp = getRdsDoc lang (sugars exts)
  createAndWriteFile (path </> "constructs.yaml") rp

getRdsDoc :: Lang -> [Sugar] -> String
getRdsDoc lang sugars =
  let sgns = map sgName sugars
      deps = resolveDependencies lang
      (surf, core) = partitionKey (isSg sgns) deps
      coreConstrs = getConstr lang \\ sgns
      attrs = [ ("Surf", getConstructRP surf)
              , ("Core", prCore coreConstrs)
              , ("SurfDeps", getDepsRP surf)
              , ("CoreDeps", getDepsRP core)
              ]
  in render $ setManyAttrib attrs $ newSTMP reportTM
  where isSg :: [String] -> QName -> Bool
        isSg sgns (QName [qname]) = qname `elem` sgns
        isSg _ _                  = False
        prCore :: [String] -> String
        prCore constrs = show $ vsep $ map (("-" <+>) . pretty) constrs

getConstr :: Lang -> [String]
getConstr lang = concat $ typeDecl lang <&> \(DataDeclaration _ _ constrs) -> map fst constrs

getConstructRP :: Map QName [QName] -> String
getConstructRP surfs = show $ vsep $ map (("-" <+>) . pretty) (keys surfs)

getDepsRP :: Map QName [QName] -> String
getDepsRP deps = show $ pretty (Dependency deps)

reportTM :: String
reportTM = [r| # Generated by Osazone-core.
#
# Filter the constructs used in the surface language. Their
# dependencies are listed below.

# Surface language constructs.
#
# You can use them directly in the language. And information
# about them will be given directly. Their dependencies are
# available as Surface option by default.

Surface:
$Surf$

# Internal language constructs.
#
# For internal use in language-related tools only. Users will
# not be able to use them directly while programming, and the
# information for them will not be displayed (unless you ask
# it to do so). Their dependencies are available as Internal
# option by default.

Internal:
$Core$

# Option: Simplification
#
# Remove internal constructs not dependent by surface constructs.

Simplification: True

# Dependencies in the mixed language.
# We place the dependencies of syntactic sugars first.
#
# ====================================================
# Syntactic Sugars:
#
$SurfDeps$
#
# ====================================================
# Core Constructs:
#
$CoreDeps$
#
|]

partitionKey :: Ord k => (k -> Bool) -> Map k a -> (Map k a, Map k a)
partitionKey f = bimap fromList fromList . partition (f . fst) . toList
-}